# A quick tour

ðŸ¤— Evaluate provides access to a wide range of evaluation tools. It covers a range of modalities such as text, computer vision, audio, etc. as well as tools to evaluate models or datasets. These tools are split into three categories.

## Three types of evaluations

There are different aspects of a typical machine learning pipeline that can be evaluated and for aspect we provide a tool:

- **Metric**: A metric is used to evaluate a model's performance and usually involves the model's predictions as well as some ground truth labels. You can find all integrated metrics at [evaluate-metric](hf.co/evaluate-metric).
- **Comparison**: A comparison is used to compare two models. This can for example be done by comparing their predictions to ground truth labels and compute their agreement. You can find all integrated comparisons at [evaluate-comparison](hf.co/evaluate-comparison).
- **Measurement**: As important as the model is the dataset used to train it. With measurements one can investigate a dataset's properties. You can find all integrated measurements at [evaluate-measurement](hf.co/evaluate-measurement).

For all of these methods there is a single entry point: [`evaluate.load`]!

## Load

Any metric, comparison, or measurement is loaded with the `evaluate.load` function: 

```py
>>> import evaluate
>>> accuracy = evaluate.load("accuracy")
```

If you want to make sure you are loading the right type of module especially if there are name clashes you can explicitely pass the type:

```py
>>> word_length = evaluate.load("word_length", type="measurement")
```

### Community modules

Besides the modules implemented in ðŸ¤— Evaluate you can also load any community module by prepending the users name:

```py
>>> element_count = evaluate.load("lvwerra/element_count", type="measurement")
```

## Module attributes

All evalution modules come with a range of useful attributes that help to use a module stored in a `EvaluationModuleInfo` object.

|Attribute|Description|
|---|---|
|`description`|A short description of the evaluation module.|
|`citation`|A BibTex string for citation.|
|`features`|A `Features` object defining the input format.|
|`inputs_description`|This is equivalent to the modules docstring.|
|`homepage`|The homepage of the module.|
|`license`|The license of the module.|
|`codebase_urls`|Link to the code behind the module.|
|`reference_urls`|Additional reference URLs.|

Let's have a look at a few examples. First, let's look at the `description` attribute of the accuracy metric:

```py
>>> accuracy = evaluate.load("accuracy")
>>> accuracy.description
Accuracy is the proportion of correct predictions among the total number of cases processed. It can be computed with:
Accuracy = (TP + TN) / (TP + TN + FP + FN)
 Where:
TP: True positive
TN: True negative
FP: False positive
FN: False negative
```

You can see that it describes how the metric works in theory. If you use this metric for you work, especially if it is an academic publication you want to reference it properly. For that you can look at the `citation` attribute:

```py
>>> accuracy.citation
@article{scikit-learn,
  title={Scikit-learn: Machine Learning in {P}ython},
  author={Pedregosa, F. and Varoquaux, G. and Gramfort, A. and Michel, V.
         and Thirion, B. and Grisel, O. and Blondel, M. and Prettenhofer, P.
         and Weiss, R. and Dubourg, V. and Vanderplas, J. and Passos, A. and
         Cournapeau, D. and Brucher, M. and Perrot, M. and Duchesnay, E.},
  journal={Journal of Machine Learning Research},
  volume={12},
  pages={2825--2830},
  year={2011}
}
```

Before we can apply a metric or other evaluation module to a use-case we need to know what the input format of the metric is:

```py
>>> accuracy.features
{
    'predictions': Value(dtype='int32', id=None),
    'references': Value(dtype='int32', id=None)
}
```

<Tip>
Note that features always describe the type of a single input element. In general we will add list of elements so you can always think of a list around the types in `features`. Evaluate accepts various input formats (Python lists, NumPy arrays, PyTorch tensors, etc.) and converts them to an appropriate format for storage and computation.
<\Tip>

## Compute

Now that we know how the evaluation module works and what should go in there we want to actually use it! When it comes to computing the actual score there are two main ways to do it:

1. All-in-one
2. Incremental


In the incremental approach the necessary inputs are added to the module with [`add`] or [`add_batch`] and the score is calculated at the end with [`compute`]. Alternatively, one can pass all the inputs at once to [`compute`]. Let's have a look at the two approaches.

### `compute`
The simplest way to calculate the score of an evaluation module is by calling [`compute`] directly with the necessary inputs. Simply pass the inputs as seen in `features` to the `compute` method.

```py
>>> accuracy.compute(references=[0,1,0,1], predictions=[1,0,0,1])
{'accuracy': 0.5}
```
Evaluation modules return the results in a dictionary. However, in some instances you build up the predictions iteratively or in a distributed fashion in which case `add` or `add_batch` are useful.

### `add` and `add_batch`

In many evaluation pipelines you build the predictions iteratively such as in a for-loop. In that case you could store the predictions in a list and at the end pass them to `compute`. With `add` and add batch you can circumvent the step of storing the predictions separately. If you are only creating single predictions at a time you can use `add`:

```py
>>> for ref, pred in zip([0,1,0,1], [1,0,0,1]):
>>>     accuracy.add(references=ref, predictions=pred)
>>> accuracy.compute()
{'accuracy': 0.5}
```

Once you have gathered all predictions you can call`compute` to compute the score based on all stored values. When getting predictions and references in batches you can use `add_batch` which adds a list elements for later processing. The rest works as with `add`:

```py
>>> for refs, preds in zip([[0,1],[0,1]], [[1,0],[0,1]]):
>>>     accuracy.add_batch(references=refs, predictions=preds)
>>> accuracy.compute()
{'accuracy': 0.5}
```

This is especially useful when you need to get the predictions from your model in batches:

```py
>>> for model_inputs, gold_standards in evaluation_dataset:
>>>     predictions = model(model_inputs)
>>>     metric.add_batch(references=gold_standards, predictions=predictions)
>>> metric.compute()

### Distributed evaluation

Computing metrics in a distributed environment can be tricky. Metric evaluation is executed in separate Python processes, or nodes, on different subsets of a dataset. Typically, when a metric score is additive (`f(AuB) = f(A) + f(B)`), you can use distributed reduce operations to gather the scores for each subset of the dataset. But when a metric is non-additive (`f(AuB) â‰  f(A) + f(B)`), it's not that simple. For example, you can't take the sum of the [F1](https://huggingface.co/metrics/f1) scores of each data subset as your **final metric**.

A common way to overcome this issue is to fallback on single process evaluation. The metrics are evaluated on a single GPU, which becomes inefficient.

ðŸ¤— Evaluate solves this issue by only computing the final metric on the first node. The predictions and references are computed and provided to the metric separately for each node. These are temporarily stored in an Apache Arrow table, avoiding cluttering the GPU or CPU memory. When you are ready to `EvaluationModule.compute` the final metric, the first node is able to access the predictions and references stored on all the other nodes. Once it has gathered all the predictions and references, `EvaluationModule.compute` will perform the final metric evaluation.

This solution allows ðŸ¤— Evaluate to perform distributed predictions, which is important for evaluation speed in distributed settings. At the same time, you can also use complex non-additive metrics without wasting valuable GPU or CPU memory. distributed predictions, which is important for evaluation speed in distributed settings. At the same time, you can also use complex non-additive metrics without wasting valuable GPU or CPU memory.

## Save and share

**TODO**: add references to [`evalute.save`] and [`evalute.push_to_hub`].